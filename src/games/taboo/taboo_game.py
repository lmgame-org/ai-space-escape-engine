from src.games.base_game import BaseGame
import random
import json
import os
import re
from typing import Optional, Any  # Added for type hints
from fschat.conversation_game import Conversation

class TabooGame(BaseGame):
    def __init__(
        self,
        difficulty: str,
        game_level: int = 1,
        user_id: Optional[int] = 0,
        username: Optional[str] = "anonymous",
        conversation: Optional[Conversation] = None,  # Added 'conversation' parameter
        game_secret: Optional[str] = None,
        round: int = 0,  # Added 'round' parameter
        game_over: bool = False,  # Added 'game_over' parameter
        game_status: Optional[str] = None,  # Added 'game_status' parameter
        model_name: Optional[str] = None  # Added 'model_name' parameter
    ):
        super().__init__(
            difficulty=difficulty,
            max_rounds=5,
            round=round,
            model_name=model_name,
            conversation=conversation,
            user_id=user_id,
            username=username
        )  # Passed parameters to BaseGame

        # self.round = 0  # Commented out; using self.round from BaseGame
        self.game_level = game_level
        self.game_over = game_over  # Set game_over
        self.game_status = game_status  # Set game_status
        self.game_secret = game_secret

        # Load system prompts
        prompt_file = os.path.join(os.path.dirname(__file__), 'taboo_optimized_prompts.json')
        with open(prompt_file, 'r') as f:
            system_prompts = json.load(f)
        self.system_prompt = random.choice(list(system_prompts.values()))

        hint_prompt_file = os.path.join(os.path.dirname(__file__), 'taboo_hint_prompts.json')
        with open(hint_prompt_file, 'r') as f:
            hint_prompts = json.load(f)
        self.hint_prompt = random.choice(list(hint_prompts.values()))

        # Set system prompt if not provided (self.conversation generated by super class if necessary)
        if not conversation and "o1" not in self.model_name:
            self.conversation.set_system_message(self.system_prompt)

        # Load taboo words
        # Start of Selection
        taboo_file = os.path.join(os.path.dirname(__file__), 'taboo.json')
        with open(taboo_file, 'r') as f:
            TABOO_GAME_WORD_CHOICES = {}
            taboo_words = json.load(f)
            self.game_hint = taboo_words.get(self.game_secret, None)
        if not game_secret:
                TABOO_GAME_WORD_CHOICES["level_1"] = list(taboo_words["animals"].keys())
                TABOO_GAME_WORD_CHOICES["level_2"] = list(taboo_words["city-country"].keys())
                TABOO_GAME_WORD_CHOICES["level_3"] = list(taboo_words["food"].keys())

                #for category in taboo_words:
                #    if category not in ["animals", "city-country"]:
                #        TABOO_GAME_WORD_CHOICES["level_3"].extend(taboo_words[category].keys())

                level_key = f"level_{game_level}"
                if level_key in TABOO_GAME_WORD_CHOICES and TABOO_GAME_WORD_CHOICES[level_key]:
                    self.game_secret = random.choice(TABOO_GAME_WORD_CHOICES[level_key])
                    # Find the hint for the selected word
                    self.game_hint = taboo_words.get(self.game_secret, None)
                else:
                    raise ValueError(f"Invalid game level or no words available for level: {game_level}")

    def is_game_over(self):
        return self.game_over

    def check_valid_guess(self, ai_message):
        pattern = r"my guess of the word is:"
        return bool(re.search(pattern, ai_message.lower()))
    
    def is_llm_giving_answer(self, ai_message):
        """
        Check if the AI has attempted a guess.
        """
        ai_guess = re.search(r"my guess of the word is:\s*([^\s.]+)", ai_message.lower())
        if ai_guess:
            return True, ai_guess.group(1)
        else:
            return False, None
    
    def check_user_win(self, ai_guess):
        """
        Determine if the user wins based on the AI's guess and the actual secret word.
        """
        # lenient rule-based check: any partial match would count
        if ai_guess in self.game_secret.lower() or self.game_secret.lower() in ai_guess:
            return False  # AI guessed correctly; user loses
        else:
            return True  # AI guessed incorrectly; user wins

    def check_word_uttered(self, ai_message):
        return self.game_secret.lower() in ai_message.lower()
    
    def choose_assistant_prompt(self):
        prompt_file = os.path.join(os.path.dirname(__file__), 'taboo_optimized_assistant_prompts.json')
        with open(prompt_file, 'r') as f:
            system_prompts = json.load(f)
        all_prompts = list(system_prompts.values())

        assistant_system_prompt = random.choice(all_prompts)
        return assistant_system_prompt

    def parse_game_history(self, game_history):
        parsed_history = []

        if game_history == []:
            message = "Secret target word provided by the system: " + self.game_secret + "\n\n"
            parsed_history.append(f"[assistant]: {message}")
        else:
            for i, exchange in enumerate(game_history):
                role, message = exchange
                # Swap roles: 'user' -> 'assistant' and 'assistant' -> 'user'
                swapped_role = "assistant" if role.lower() == "user" else "user"
                if i == 0:
                    message = "Secret target word provided by the system: " + self.game_secret + "\n\n" + message
                parsed_history.append(f"[{swapped_role}]: {message}")

        # Join all entries into a single string
        return " ".join(parsed_history)
    
    def extract_answer(self, answers):
        # Updated pattern to allow one or more newline characters
        pattern = r"^Question 1: (.+?)\n+Question 2: (.+?)$"

        # Match the entire text to ensure formatting
        match = re.fullmatch(pattern, answers.strip())

        if match:
            first_answer, second_answer = match.groups()
            return first_answer, second_answer
        else:
            # Return None if the format doesn't match
            return None
