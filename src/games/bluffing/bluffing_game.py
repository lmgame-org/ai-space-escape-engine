import random
import json
import os
import re
from typing import Optional, Dict  # Added for type hints
from src.games.base_game import BaseGame
from src.fschat.conversation_game import Conversation

class BluffingGame(BaseGame):
    def __init__(
        self,
        difficulty: str,
        game_level: int = 1,
        user_id: Optional[int] = 0,
        username: Optional[str] = "anonymous",
        conversation: Optional[Conversation] = None,  # Added 'conversation' parameter
        system_question: Optional[Dict] = None,
        round: int = 0,  # Added 'round' parameter
        game_over: bool = False,  # Added 'game_over' parameter
        game_status: Optional[str] = None,  # Added 'game_status' parameter
        model_name: Optional[str] = None  # Added 'model_name' parameter
    ):
        max_rounds = game_level * 2 + 4
        super().__init__(
            difficulty=difficulty,
            max_rounds=max_rounds,
            round=round,
            model_name=model_name,
            conversation=conversation,
            user_id=user_id,
            username=username
        )  # Passed parameters to BaseGame

        self.game_level = game_level
        self.game_over = game_over  # Set game_over
        self.game_status = game_status  # Set game_status

        hint_prompt_file = os.path.join(os.path.dirname(__file__), 'bluffing_hint_prompts.json')
        with open(hint_prompt_file, 'r') as f:
            hint_prompts = json.load(f)
        self.hint_prompt = random.choice(list(hint_prompts.values()))

        # Load system prompts
        if system_question:
            deserialized_system_question = json.loads(system_question)
            self.system_question = deserialized_system_question
        else:
            prompt_file = os.path.join(os.path.dirname(__file__), 'bluffing_optimized_prompts.json')
            with open(prompt_file, 'r') as f:
                system_prompts = json.load(f)
            all_prompts = list(system_prompts.values())

            self.system_prompt = random.choice(all_prompts)
            self.system_prompt_index = all_prompts.index(self.system_prompt)

            # Load bluffing questions
            bluffing_questions_file = os.path.join(os.path.dirname(__file__), 'bluffing.json')
            with open(bluffing_questions_file, 'r') as f:
                self.bluffing_questions = json.load(f)

            random_topic = random.choice(self.bluffing_questions['topics'])
            random_topic_statement = random_topic['topic']
            level_statement = random_topic['levels'].get(f'level_{self.game_level}', None)

            topic_and_level = {
                "topic": random_topic_statement,
                "bluffing_statement": level_statement
            }

            self.system_question = topic_and_level


        # Initialize conversation
        # self.round = 0  # Commented out; now using self.round from BaseGame

        # Game-specific attributes

        # Set system prompt if not provided (self.conversation generated by super class if necessary)
        if not conversation and "o1" not in self.model_name:
            self.conversation.set_system_message(self.system_prompt)

    def is_game_over(self):
        return self.game_over

    def check_valid_guess(self, ai_message):
        pattern = r"i believe your statement is:\s*(true|false)"
        return bool(re.search(pattern, ai_message.lower()))

    def is_llm_giving_answer(self, ai_message):
        return self.check_valid_guess(ai_message)

    def check_user_win(self, ai_message, user_statement_truth):
        """
        Determine if the user wins based on the AI's guess and the actual truth of the user's statement.
        """
        ai_guess = re.search(r"i believe your statement is:.*?(true|false)", ai_message.lower())
        if ai_guess:
            ai_guess = ai_guess.group(1)
            if ai_guess == user_statement_truth.lower():
                return False  # AI guessed correctly; user loses
            else:
                return True  # AI guessed incorrectly; user wins
        return False  # no valid guess

    def choose_assistant_prompt(self):
        prompt_file = os.path.join(os.path.dirname(__file__), 'bluffing_optimized_assistant_prompts.json')
        with open(prompt_file, 'r') as f:
            system_prompts = json.load(f)
        all_prompts = list(system_prompts.values())

        assistant_system_prompt = random.choice(all_prompts)
        return assistant_system_prompt
    

    def parse_game_history(self, game_history):
        parsed_history = []

        for exchange in game_history:
            role, message = exchange
            # Swap roles: 'user' -> 'assistant' and 'assistant' -> 'user'
            swapped_role = "assistant" if role.lower() == "user" else "user"
            parsed_history.append(f"[{swapped_role}]: {message}")

        # Join all entries into a single string
        return " ".join(parsed_history)
    
    def extract_answer(self, answers):

        pattern = r"Answer 1:\s*(.*?)\s*Answer 2:\s*(.*)"
    
        # Match the entire text to ensure strict formatting
        match = re.fullmatch(pattern, answers.strip())
    
        if match:
            first_answer, second_answer = match.groups()
            return first_answer, second_answer
        else:
            # Return None if the format doesn't match strictly
            return None

